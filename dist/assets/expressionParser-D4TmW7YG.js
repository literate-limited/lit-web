const _={pi:Math.PI,e:Math.E,tau:Math.PI*2},$=Math.log10??(e=>Math.log(e)/Math.LN10),U=Math.log2??(e=>Math.log(e)/Math.LN2),I=Math.cbrt??(e=>Math.pow(e,1/3)),S={sin:{fn:Math.sin,minArgs:1,maxArgs:1},cos:{fn:Math.cos,minArgs:1,maxArgs:1},tan:{fn:Math.tan,minArgs:1,maxArgs:1},asin:{fn:Math.asin,minArgs:1,maxArgs:1},acos:{fn:Math.acos,minArgs:1,maxArgs:1},atan:{fn:Math.atan,minArgs:1,maxArgs:1},atan2:{fn:Math.atan2,minArgs:2,maxArgs:2},sinh:{fn:Math.sinh,minArgs:1,maxArgs:1},cosh:{fn:Math.cosh,minArgs:1,maxArgs:1},tanh:{fn:Math.tanh,minArgs:1,maxArgs:1},log:{fn:(e,r)=>r==null?Math.log(e):Math.log(e)/Math.log(r),minArgs:1,maxArgs:2},ln:{fn:Math.log,minArgs:1,maxArgs:1},log10:{fn:$,minArgs:1,maxArgs:1},log2:{fn:U,minArgs:1,maxArgs:1},sqrt:{fn:Math.sqrt,minArgs:1,maxArgs:1},cbrt:{fn:I,minArgs:1,maxArgs:1},abs:{fn:Math.abs,minArgs:1,maxArgs:1},exp:{fn:Math.exp,minArgs:1,maxArgs:1},pow:{fn:Math.pow,minArgs:2,maxArgs:2},floor:{fn:Math.floor,minArgs:1,maxArgs:1},ceil:{fn:Math.ceil,minArgs:1,maxArgs:1},round:{fn:Math.round,minArgs:1,maxArgs:1},sign:{fn:Math.sign,minArgs:1,maxArgs:1},min:{fn:Math.min,minArgs:1,maxArgs:1/0},max:{fn:Math.max,minArgs:1,maxArgs:1/0},hypot:{fn:Math.hypot,minArgs:1,maxArgs:1/0},clamp:{fn:(e,r,t)=>Math.min(t,Math.max(r,e)),minArgs:3,maxArgs:3},mod:{fn:(e,r)=>e%r,minArgs:2,maxArgs:2}},A=(e,r)=>((e==null?void 0:e.message)||r).split(`
`)[0].slice(0,90),T=e=>{let r=(e??"").trim();if(!r)return"";const t=r.indexOf("=");return t!==-1&&(r=r.slice(t+1)),r.trim()},F=e=>{const r=[];let t=0;for(;t<e.length;){const n=e[t];if(/\s/.test(n)){t+=1;continue}if(/[0-9.]/.test(n)){const s=t;let l=!1;if(n==="."){if(t+1>=e.length||!/\d/.test(e[t+1]))throw new Error('Unexpected token "."');l=!0,t+=1}for(;t<e.length&&/\d/.test(e[t]);)t+=1;if(t<e.length&&e[t]==="."){if(l)throw new Error('Unexpected token "."');for(l=!0,t+=1;t<e.length&&/\d/.test(e[t]);)t+=1}if(t<e.length&&/[eE]/.test(e[t])){let i=t+1;if(/[+-]/.test(e[i])&&(i+=1),i>=e.length||!/\d/.test(e[i]))throw new Error('Unexpected token "e"');for(t=i+1;t<e.length&&/\d/.test(e[t]);)t+=1}r.push({type:"number",value:Number(e.slice(s,t))});continue}if(/[a-zA-Z_]/.test(n)){const s=t;for(t+=1;t<e.length&&/[a-zA-Z0-9_]/.test(e[t]);)t+=1;r.push({type:"ident",value:e.slice(s,t)});continue}if(n==="("){r.push({type:"open_paren",value:n}),t+=1;continue}if(n===")"){r.push({type:"close_paren",value:n}),t+=1;continue}if(n===","){r.push({type:"comma",value:n}),t+=1;continue}if(n==="|"){r.push({type:"pipe",value:n}),t+=1;continue}if(n==="*"&&e[t+1]==="*"){r.push({type:"op",value:"^"}),t+=2;continue}if("+-*/^%".includes(n)){r.push({type:"op",value:n}),t+=1;continue}throw new Error(`Unexpected token "${n}"`)}return r},x=e=>e&&["number","variable","constant","close_paren","abs_close"].includes(e.type),y=e=>e?e.type==="number"?String(e.value):e.type==="variable"||e.type==="constant"||e.type==="function"?e.value:e.type==="abs_open"||e.type==="abs_close"?"|":e.type==="open_paren"?"(":e.type==="close_paren"?")":e.type==="comma"?",":e.type==="op"?e.value:e.type:"end of input",v=(e,r)=>r===1/0?`at least ${e}`:e===r?`${e}`:`${e}-${r}`,L=(e,r,t,n)=>{const s=[];let l=null;const i=new Set((r||[]).map(c=>c.toLowerCase()));for(const c of e){if(c.type==="pipe"){const p=!l||!x(l)?"abs_open":"abs_close";s.push({type:p,value:"|"})}else if(c.type==="ident"){const p=c.value.toLowerCase();if(t[p])s.push({type:"function",value:p});else if(Object.prototype.hasOwnProperty.call(n,p))s.push({type:"constant",value:p});else if(i.has(p))s.push({type:"variable",value:p});else throw new Error(`Unknown identifier "${c.value}"`)}else s.push(c);l=s[s.length-1]}return s},N=e=>{const r=[],t=n=>n&&["number","variable","constant","function","open_paren","abs_open"].includes(n.type);for(const n of e){const s=r[r.length-1];x(s)&&t(n)&&r.push({type:"op",value:"*"}),r.push(n)}return r},O=(e,r,t)=>{const{minArgs:n,maxArgs:s}=t[e];if(r<n||r>s)throw new Error(`${e} expects ${v(n,s)} args`)},C=(e,r,t)=>{let n=0;const s=()=>e[n],l=()=>e[n++],i=(a,o)=>{const u=s();return!u||u.type!==a?!1:(n+=1,!0)},c=(a,o)=>{const u=s();if(!u||u.type!==a||o!=null)throw new Error(`Expected "${a}", got "${y(u)}"`);return l()},p=a=>a&&["number","variable","constant","function","open_paren","abs_open"].includes(a.type),f=()=>w(),w=()=>{let a=g();for(;;){const o=s();if((o==null?void 0:o.type)==="op"&&(o.value==="+"||o.value==="-")){l();const u=g();a={type:"binary",op:o.value,left:a,right:u}}else break}return a},g=()=>{let a=h();for(;;){const o=s();if((o==null?void 0:o.type)==="op"&&["*","/","%"].includes(o.value)){l();const u=h();a={type:"binary",op:o.value,left:a,right:u}}else if(p(o)){const u=h();a={type:"binary",op:"*",left:a,right:u}}else break}return a},h=()=>{const a=s();return(a==null?void 0:a.type)==="op"&&(a.value==="+"||a.value==="-")?(l(),{type:"unary",op:a.value,expr:h()}):b()},b=()=>{let a=d();const o=s();if((o==null?void 0:o.type)==="op"&&o.value==="^"){l();const u=h();a={type:"binary",op:"^",left:a,right:u}}return a},M=()=>{const a=c("function"),o=[];if(i("open_paren")){if(i("close_paren"))throw new Error(`${a.value} expects ${v(r[a.value].minArgs,r[a.value].maxArgs)} args`);for(o.push(f());i("comma");)o.push(f());c("close_paren")}else o.push(g());return O(a.value,o.length,r),{type:"call",name:a.value,args:o}},d=()=>{const a=s();if(!a)throw new Error("Unexpected end of input");if(a.type==="number")return l(),{type:"number",value:a.value};if(a.type==="variable")return l(),{type:"variable",name:a.value};if(a.type==="constant")return l(),{type:"number",value:t[a.value]};if(a.type==="function")return M();if(a.type==="open_paren"){l();const o=f();return c("close_paren"),o}if(a.type==="abs_open"){l();const o=f();return c("abs_close"),{type:"call",name:"abs",args:[o]}}throw new Error(`Unexpected token "${y(a)}"`)},E=f();if(n<e.length)throw new Error(`Unexpected token "${y(e[n])}"`);return E},m=(e,r,t)=>{switch(e.type){case"number":return e.value;case"variable":{if(!Object.prototype.hasOwnProperty.call(r,e.name))throw new Error(`Variable "${e.name}" is not defined`);return r[e.name]}case"unary":{const n=m(e.expr,r,t);return e.op==="-"?-n:n}case"binary":{const n=m(e.left,r,t),s=m(e.right,r,t);switch(e.op){case"+":return n+s;case"-":return n-s;case"*":return n*s;case"/":return n/s;case"%":return n%s;case"^":return Math.pow(n,s);default:throw new Error(`Unknown operator "${e.op}"`)}}case"call":{const n=t[e.name],s=e.args.map(l=>m(l,r,t));return n.fn(...s)}default:throw new Error(`Unknown node "${e.type}"`)}},P=(e,{variables:r=["x"],functions:t=S,constants:n=_}={})=>{const s=(e??"").trim();if(!s)return{evaluator:null,error:"Enter expression"};let l;try{l=T(s)}catch(i){return{evaluator:null,error:A(i,"Fix expression")}}if(!l)return{evaluator:null,error:"Enter expression"};try{const i=N(L(F(l),r,t,n)),c=C(i,t,n);return{evaluator:f=>m(c,f,t),error:null,ast:c,normalized:l}}catch(i){return{evaluator:null,error:A(i,"Fix expression")}}};export{P as c};
